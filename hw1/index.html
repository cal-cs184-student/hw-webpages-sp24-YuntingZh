<!DOCTYPE html>
<html>

<head>
    <title>Computer Graphics Homework Report</title>
    <link rel="stylesheet" type="text/css" href="css/style.css">
</head>

<body>
    <header>
        <div class="container">
            <div id="branding">
                <h1>Computer Graphics Homework Report</h1>
            </div>
            <nav>
                <ul>
                    <li class="current"><a href="#overview">Overview</a></li>
                    <li><a href="#task1">Task 1</a></li>
                    <li><a href="#task2">Task 2</a></li>
                    <li><a href="#task3">Task 3</a></li>
                    <li><a href="#task4">Task 4</a></li>
                    <li><a href="#task5">Task 5</a></li>
                    <li><a href="#task6">Task 6</a></li>
                    <li><a href="#extra">Extra Credit</a></li>
                </ul>
            </nav>
        </div>
    </header>

    <section id="overview">
        <div class="container">
            <h2 class="section-title">Overview</h2>
            <p>
                <!-- Insert your overview here -->
            </p>
        </div>
    </section>

    <!-- Add sections for each task here -->
    <!-- Task 1 Section -->
    <section id="task1">
        <div class="container">
            <h2 class="section-title">Task 1: Rasterization of Triangles</h2>
            <h3>Overview</h3>
            <p>
                The task involves implementing basic triangle rasterization without supersampling. The goal is to
                rasterize
                triangles using the point-in-triangle test for each pixel, with a sample point located at the center of
                each
                pixel. The implementation should ensure that the triangle is drawn correctly regardless of its winding
                order
                and that no edges are left un-rasterized. The approach involves calculating the triangle's bounding box
                and
                iterating over each pixel within the bounding box to perform the point-in-triangle test. The details of
                the
                steps are: </p>
            <ul class="abcd-list">
                <li>
                    <strong>Finding the Bounding Box:</strong> The first step is calculating the smallest rectangle
                    (bounding
                    box) that completely encloses the triangle. This is done by finding the minimum and maximum X and Y
                    coordinates among the triangle's three vertices. This step is crucial because it limits the area
                    needed
                    to check for filling in the triangle, making the process more efficient.
                </li>
                <li>
                    <strong>Iterating Over Each Pixel:</strong> Next, the code loops through each pixel within this
                    bounding box.
                    For each pixel, it determines if the pixel's center is inside the triangle.
                </li>
                <li>
                    <strong>Point-in-Triangle Test:</strong> Barycentric coordinates must be applied to decide if a
                    pixel is part of
                    the triangle. By adding 0.5 to both the X and Y coordinates of the pixel, it can be ensured that the
                    test is
                    done at the center of the pixel, not the corner. This is a more accurate way to color the triangle.
                </li>
                <li>
                    <strong>Coloring the Pixel:</strong> If the center of a pixel is found to be inside the triangle,
                    the pixel is colored
                    with the specified color.
                </li>
            </ul>

            <!-- More about Point-in-Triangle Test -->
            <p>
                In Lecture 2, we discussed how to test whether a point is inside a triangle. A common approach is the
                vector-based method.
                For me, the vector method is intuitive, essentially involving a simple check of the cross product values
                to see if they are on the same side. If a point is on the same side of all edges, then it's inside the
                triangle. A key aspect of this method is maintaining a consistent direction for the edges, typically
                clockwise or counterclockwise. If the edges of the triangle are arranged in a consistent direction (such
                as clockwise or counterclockwise), then this method is very effective. Based on this, I implemented this
                approach.
            <h3>Vector method</h3>
            <code>
bool RasterizerImp::isPointInTriangle(float x, float y, float x0, float y0, float x1, float y1, float x2, float y2) {<br>
    // Method 2: Vector cross product(edge function) method<br>
    // Convert triangle vertices and point into vectors<br>
    float v0x = x1 - x0;<br>
    float v0y = y1 - y0;<br>
    float v1x = x2 - x1;<br>
    float v1y = y2 - y1;<br>
    float v2x = x0 - x2;<br>
    float v2y = y0 - y2;<br><br>

    // Convert the test point into vectors relative to triangle vertices<br>
    float pv0x = x - x0;<br>
    float pv0y = y - y0;<br>
    float pv1x = x - x1;<br>
    float pv1y = y - y1;<br>
    float pv2x = x - x2;<br>
    float pv2y = y - y2;<br><br>

    // Compute the cross products<br>
    float cross0 = v0x * pv0y - v0y * pv0x;<br>
    float cross1 = v1x * pv1y - v1y * pv1x;<br>
    float cross2 = v2x * pv2y - v2y * pv2x;<br><br>

    // Check the sign of the cross products to determine if the point is on the same side of all edges<br>
    if ((cross0 >= 0 && cross1 >= 0 && cross2 >= 0) || (cross0 <= 0 && cross1 <= 0 && cross2 <= 0)) {<br>
        return true; // Point is inside the triangle<br>
    }<br>
    else {<br>
        return false; // Point is outside the triangle<br>
    }<br>
}
</code>
            Another method is the barycentric method, which we discussed in Lecture 5. This method can be efficiently
            constrained within the triangle's bounding box and can easily handle different winding orders.

            <h3>barycentric method</h3>
            <code>
    bool RasterizerImp::isPointInTriangle(float x, float y, float x0, float y0, float x1, float y1, float x2, float y2) {<br>
        // Method 1: Calculate vectors & dot products for barycentric coordinates<br>
        float denom = (y1 - y2) * (x0 - x2) + (x2 - x1) * (y0 - y2);<br>
        float a = ((y1 - y2) * (x - x2) + (x2 - x1) * (y - y2)) / denom;<br>
        float b = ((y2 - y0) * (x - x2) + (x0 - x2) * (y - y2)) / denom;<br>
        float c = 1 - a - b;<br><br>
    
        // Check if point is inside the triangle<br>
        return a >= 0 && a <= 1 && b >= 0 && b <= 1 && c >= 0 && c <= 1;<br>
    }
    </code>

            TODO: I have not yet optimized the algorithm to be “no worse than checking each sample within the bounding
            box of the triangle”. The key to this step is reducing unnecessary checks.
            We also encountered a small issue regarding the rounding, which was fixed by using floor and ceiling
            rounding methods

            <img src="../images/Task1_checkRounding.png" alt="checkRounding">
            <div class="image-container">
                <img class="uniform-pictures" src="../images/Task1_svg3notfilled.png" alt="Task 1 - issue">

                <img class="uniform-pictures" src="../images/Task1_problemFixed.png" alt="Task 1 - test 3">
                <img class="uniform-pictures" src="../images/Task1_test6img.png" alt="Task 1 - test 6">
                <img class="uniform-pictures" src="../images/Task1_test4SVGwithPixelInspector.png"
                    alt="Task 1 - test 4">
            </div>

            <p class="img-description">Fixed - svg3notfilled</p>
            <!-- Add more paragraphs or images as needed -->
        </div>
    </section>
    <section id="task2">
        <div class="container">
            <h2 class="section-title">Task 2: Antialiasing by Supersampling</h2>
            <p>
                <!-- Write a brief introduction or overview of Task 1 here -->
            </p>
            <p>
            <section id="task2">
                <div class="container">
                    <h2 class="section-title">Task 2: Antialiasing by Supersampling</h2>
                    <p>
                        <!-- Write a brief introduction or overview of Task 1 here -->
                    </p>
                    <p>
                        Supersampling is a technique where you render the scene at a higher resolution than the final
                        output and then downsample to the target resolution. This process smooths out the edges and
                        reduces the aliasing effects.
                    </p>

                    <p>
                        <!-- Add detailed explanation of your approach, implementation, and problem-solving for Task 1 here -->
                    </p>

                    <!-- If you have images to add -->
                    <img src="./images/task1_example.png" alt="Task 1 Example">
                    <p class="img-description">Description or caption for the image</p>
                    <!-- Add more paragraphs or images as needed -->
                </div>
            </section>

            </p>

            <p>
                <!-- Add detailed explanation of your approach, implementation, and problem-solving for Task 1 here -->
            </p>

            <!-- If you have images to add -->
            <img src="./images/task1_example.png" alt="Task 1 Example">
            <p class="img-description">Description or caption for the image</p>
            <!-- Add more paragraphs or images as needed -->
        </div>
    </section>


    <section id="progress-images">
        <div class="container">
            <h2 class="section-title">Work in Progress</h2>
            <div class="gallery">
                <!-- Repeat this block for each image -->
                <div class="img-wrap">
                    <a href="./images/full-size-image1.jpg" target="_blank">
                        <img src="./images/thumbnail-image1.jpg" alt="Description">
                    </a>
                    <p class="img-description">Description of the image</p>
                </div>
                <!-- Repeat ends -->
            </div>
        </div>
    </section>

    <!-- Add more sections as needed -->

    <footer>
        <div class="container">
            <p>Computer Graphics Class, 2024</p>
        </div>
    </footer>
</body>

</html>
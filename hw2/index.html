<!DOCTYPE html>
<html>

<head>
    <title>Computer Graphics Homework 2 Report</title>
    <link rel="stylesheet" type="text/css" href="../css/style.css">
</head>

<body>
    <header>
        <div class="container">
            <div id="branding">
                <h1>Computer Graphics Homework 2 Report</h1>
            </div>
            <nav>
                <!-- Section I: Task 1, Task 2 -->
                <h2>Section I</h2>
                <ul>
                    <li><a href="#task1">Task 1</a></li>
                    <li><a href="#task2">Task 2</a></li>
                </ul>

                <!-- Section II: Task 3, Task 4, Task 5, Task 6 -->
                <h2>Section II</h2>
                <ul>
                    <li><a href="#task3">Task 3</a></li>
                    <li><a href="#task4">Task 4</a></li>
                    <li><a href="#task5">Task 5</a></li>
                    <li><a href="#task6">Task 6</a></li>
                </ul>

                <!-- Extra Credit -->
                <ul>
                    <li><a href="#extra">Extra Credit</a></li>
                </ul>
            </nav>
        </div>
    </header>


    <section id="overview">
        <div class="container">
            <h2 class="section-title">Overview</h2>
            <p>
                Here's the website link:
                TBD

            </p>

        </div>
    </section>

    <!-- Section I : Task1 -->
    <section id="task1">
        <div class="container">
            <h2 style="text-align: center;">Section I: Bezier Curves and Surfaces</h2>
            <h3 style="text-align: center;">Overview</h3>
            <h4>TODO:</h4>
            <ul>
                <li>
                    Using Castlejau algorithm to evaluate Bezier curves and surfaces.
                </li>
                <li>Generate our own Bezier curve with 6 points with adjustable control points.</li>
                <li>
                    Show 3D teapot by implementing Bezier surface.
                </li>
            </ul>
            <h2 class="section-title">Task 1:Bezier Curves with 1D de Castlejau Subdivison.</h2>

            <p>
                This part aims to generate a Bezier curve and make our own style with 6 points. Behind the scenes of this curve, the crucial part is implementing Castlejau’s algorithm to evaluate the curve. It's a numerical method that recursively subdivides the curve at each iteration step, moving from the initial control points to the evaluation point on the curve. The Bezier curve is made from a series of control points, and de Castlejau’s algorithm enables us to calculate the control points by using t as a parameter, with values ranging from 0 – 1. When t = 0, the point on the curve is the first control point, and when t = 1, the point on the curve is the last control point.
            <p>
            <p>
                In order to implement Castlejau’s algorithm on this first task 1, we need to pay attention to the header file that stores std::vector<Vector2D>
                    controlPoints: A std::vector and float t.
                    <div style="text-align:center;">
                        <img src="../hw2_IMGs/Task1_headerfile.png" alt="Task 3 before" style="width:200%; margin:auto;">
                    </div>

            </p>
            <p>
                We defined a function evaluateStep, creating a new vector to store the interpolated points. Going back to the definition again, the Bezier curve is a curve that can be manipulated by using a series of control points. Its degree of n is defined by n+1 control points and based on parameter t with a value starting from 0 – 1 (start to end point of curve). This specific loop iterates through each pair of consecutive control points to generate a new set of control points.
            </p>

            <div style="text-align:center;">
                <img src="../hw2_IMGs/Task1_student_code.png" alt="Task 3 before" style="width:300%; margin:auto;">
            </div>

            <p>
                To apply the Castlejau’s method, inside a loop, we calculate the interpolated point between each pair of consecutive points using the formula (1 - t) * currentPoint + t * nextPoint. This generates the points for the next level of the algorithm. We continue this process recursively by calling evaluateStep on the new set of points until we're left with one final point. This point is the position on the Bezier curve corresponding to the parameter t.
            </p>
            <h2>The Bezier Curves</h2>
            <!DOCTYPE html>
            <html lang="en">
            <head>
                <meta charset="UTF-8">
                <meta http-equiv="X-UA-Compatible" content="IE=edge">
                <meta name="viewport" content="width=device-width, initial-scale=1.0">
                <title>Image Gallery</title>
                <style>
                    .gallery-container {
                        text-align: center;
                    }

                    .gallery-row {
                        display: flex;
                        justify-content: center;
                    }

                    .gallery-item {
                        margin: 5px;
                    }

                    img {
                        width: 100%; /* Adjust the size to your preference */
                        max-width: 300px; /* Maximum width */
                        height: auto; /* Maintain aspect ratio */
                        display: block; /* Correct block display */
                        margin: 0 auto 10px; /* Centering and spacing for image */
                    }

                    .gallery-caption {
                        text-align: center;
                        margin-bottom: 20px; /* Spacing below caption */
                    }
                </style>
            </head>
            <body>

                <div class="gallery-container">
                    <div class="gallery-item">
                        <img src="../hw2_IMGs/Task1_curve3_6points.png" alt="Curve with 6 Points">
                        <div class="gallery-caption">Curve3 - 6 Points</div>
                    </div>

                    <div class="gallery-row">
                        <div class="gallery-item">
                            <img src="../hw2_IMGs/Task1_curve3_step1.png" alt="Step 1">
                            <div class="gallery-caption">Curve3 - Step 1</div>
                        </div>
                        <div class="gallery-item">
                            <img src="../hw2_IMGs/Task1_curve3_step2.png" alt="Step 2">
                            <div class="gallery-caption">Curve3 - Step2</div>
                        </div>
                    </div>

                    <div class="gallery-row">
                        <div class="gallery-item">
                            <img src="../hw2_IMGs/Task1_curve3_step3.png" alt="Step 3">
                            <div class="gallery-caption">Curve3 - Step3</div>
                        </div>
                        <div class="gallery-item">
                            <img src="../hw2_IMGs/Task1_curve3_step4.png" alt="Step 4">
                            <div class="gallery-caption">Curve3 - Step4</div>
                        </div>
                    </div>

                    <

                    <div class="gallery-item">
                        <img src="../hw2_IMGs/Task1_curve3_step5.png" alt="Step 5">
                        <div class="gallery-caption">Curve3 - Step 5</div>
                    </div>


                    <div class="gallery-item">
                        <img src="../hw2_IMGs/Task1_curve3_completed.png" alt="Completed Curve">
                        <div class="gallery-caption">Curve3 - Completed</div>
                    </div>

                    <div class="gallery-item">
                        <img src="../hw2_IMGs/Task1_curve3_movingpoints.png" alt="Moving Points">
                        <div class="gallery-caption">Curve3 - Moving Control Points</div>
                    </div>
                </div>

    </div>
</section>

<!-- Section II : Task3 -->

<div class="container">
    <h2 style="text-align: center;">Section II: Triangle Meshes and Half-Edge Data Structure</h2>
    <h3 style="text-align: center;">Overview</h3>
    <h4>TODO:</h4>
    <ul>
        <li>
            Read this introduction to the half-edge data structure to reinforce your understanding
            of it from Lecture 8.
        </li>
        <li>Read through this primer on how to navigate meshes using the HalfedgeMesh class.</li>
        <li>
            Read and understand the documentation at the beginning of halfedgeMesh.h, which provides
            supplementary information to the primer.
        </li>
    </ul>
    <h4>Why Bezier surfaces are much more difficult to render directly? </h4>

    <p>
        The advantage of Bezier surfaces is that they can create very smooth surfaces. They do not
        require much storage space, as only the information of those control points is needed.
        However, displaying Bezier surfaces directly on the screen is challenging because of their
        smoothness, which requires more complex calculations for accurate depiction. Therefore,
        typically, Bezier surfaces are converted into triangle meshes before being displayed on the
        screen. This allows us to see a very smooth surface of a 3D model on the screen. The storage
        method for triangle meshes needs two lists: one for vertices and one for triangles. Although
        this method is straightforward, it is limited when it comes to traversing a large number of
        triangles for complex geometric processing. For example, if I want to find all the triangles
        around a specific triangle, I need to check every triangle in the framework, which can be
        slow and complicated if there are many triangles.<span style="font-style: italic;">😫</span>
    </p>


    <p>
        Therefore, at this point, our lecture introduced the half-edge data structure, a more
        efficient way to
        handle triangle meshes. It provides quick access and more effective mesh processing. The
        characteristic of the half-edge data structure is that each triangle is not only composed of
        points (vertices) and edges, but also an additional element called "half-edge." This
        "half-edge" acts like a small bridge connecting the points and edges in a triangle, storing
        all the necessary connection information. For instance, if I now want to find all the
        triangles adjacent to a triangle, it's like having a map that not only marks all the scenic
        spots (points) but also shows how to get from one scenic spot to another (edges and faces).
    </p>
</div>
<section id="task3">
    <div class="container">
        <h2 class="section-title">Task 3 - Area-Weighted Vertex Normals</h2>

        <p>
            In class, when we covered this topic, I personally understood it through the "Shade Smooth"
            function in Blender.
        </p>
        <p>
            In Blender, there are two shading methods provided: shade flat and shade smooth. I think the
            so-called area-weighted vertex normals are similar to Blender's "Shade Smooth" function in
            that both are based on a similar concept. They are used to achieve a smoother, more natural
            surface
            effect when rendering models.
        </p>
        <img src="../hw2_IMGs/Task3_2waysOfShading.png" alt="Task 3 blender exaple">

        <h2>About My Implementation:</h2>
        <p>
            The essence of area-weighted vertex normals lies in converting the normals of a face into the
            normals
            of a vertex. A vertex may be connected to many faces, so my goal is to find a comprehensive
            average
            direction that represents all these faces.
        </p>

        <ol>
            <li>
                <strong>Calculate Each Face's Normal:</strong> Start by calculating the normal of each
                face. For
                a given vertex, find each adjacent triangle. The normal is equal to the cross product of
                two
                vectors of the triangle. Specifically, I used a loop
                <code>do {...} while (h != halfedge());</code> to traverse all the adjacent half-edges
                of a
                vertex. This ensures all the faces adjacent to that vertex are covered, and I checked if
                the
                face is a boundary face with <code>if (!h->face()->isBoundary()) {...}</code> since
                boundary
                faces may not be applicable for normal face normal calculations. Then I used
                <code>Vector3D faceNormal = cross(edge1, edge2);</code> to calculate the face's normal.
            </li>
            <li>
                <strong>Weight the Normals by Area:</strong> This ensures that larger faces have a
                greater
                impact on the vertex normal. I calculated the area with
                <code>double area = faceNormal.norm() / 2.0;</code>, allowing for a weighted
                calculation.
            </li>
            <li>
                <strong>Summation:</strong> Sum up all the normals around the vertex to get an overall
                normal
                vector. The implementation is <code>N += faceNormal.unit() * area;</code>. Here I used
                <code>faceNormal.unit()</code> because the length of the unnormalized faceNormal is
                twice the
                area. Multiplying it by the area would square the area, resulting in a physically
                meaningless
                result.
            </li>
            <li>
                <strong>Normalize the Overall Normal Vector:</strong> Scale the vector to unit length
                (i.e.,
                length of 1). <code>return N.unit();</code> The normalized normal vector maintains its
                original
                direction but with a uniform length. This is important for lighting and rendering, as it
                ensures
                that all normal vectors contribute evenly to the calculation.
            </li>
        </ol>
        <img class="uniform-pictures" src="../hw2_IMGs/Task3_before.png" alt="Task 3 before">
        <img class="uniform-pictures" src="../hw2_IMGs/Task3_after.png" alt="Task 3 after">
        <div class="card">

            <h4>Understanding the Impact of Not Normalizing:</h4>
            <p>
                If the normal vectors are not uniform in length, i.e., not normalized, several issues can
                arise
                during lighting calculations and rendering:
            </p>
            <ul>
                <li>
                    <strong>Inconsistent Lighting Calculations:</strong> In 3D rendering, normal vectors are
                    typically used for calculating lighting, especially in determining how surfaces reflect
                    light.
                    If the normal vectors are not uniform in length, lighting intensity calculations can be
                    incorrect. In lighting models like the Phong model, the length of normals affects the
                    intensity
                    of reflected light. Longer normals can make some areas appear brighter or darker than
                    they
                    actually are.
                </li>
                <li>
                    <strong>Visual Inconsistency:</strong> Non-uniform normal vectors can lead to visually
                    incoherent images. Some areas might appear abnormal, like unexpected bright spots or
                    dark areas,
                    which do not correspond to the object's actual material and lighting conditions.
                </li>
                <li>
                    <strong>Performance Impact:</strong> Normalizing normal vectors is usually a standard
                    step in
                    the rendering pipeline. If the normals are not normalized, additional calculations may
                    need to
                    be performed during the lighting processing stage, which can affect rendering
                    performance.
                </li>
                <li>
                    <strong>Cumulative Calculation Errors:</strong> In complex rendering scenes,
                    unnormalized
                    normals can lead to the accumulation of calculation errors, especially during multiple
                    rendering
                    iterations or when dealing with complex lighting effects.
                </li>
            </ul>
        </div>
    </div>
</section>

<!-- Section II : Task4 -->
<section id="task4">
    <div class="container">
        <h2 class="section-title">Task 4: Edge Flip</h2>

        <p>
            When performing operations like edge flipping, it's essentially about rearranging the connections of
            these elements. To maintain the integrity and functionality of the mesh, I need to ensure:
        </p>
        <ul>
            <li>
                Each half-edge correctly points to its corresponding next half-edge, twin half-edge, the vertex it
                belongs to, as well as its edge and face.
            </li>
            <li>Each vertex, edge, and face correctly point to one of the half-edges associated with them.</li>
        </ul>
        <p>
            This process, in my understanding, is like moving some pieces in a puzzle, where I need to ensure that
            all the puzzle pieces are still correctly fitted together. In this process, each puzzle piece (mesh
            element) needs to be correctly connected to others to maintain the integrity of the entire pattern
            (mesh). If these pointers point to the wrong elements, the mesh might experience issues, such as
            breaking or distortion (which I encountered during implementation).
        </p>

        <h2>How to Implement Edge Flip</h2>
        <ol>
            <li>
                <strong>Confirm Flip Conditions:</strong> <code>if (e0-&gt;isBoundary()) { return e0; }</code>
                Ensure that the selected edge is not a boundary edge. If the edge or its adjacent faces are boundary
                elements, do not perform the flip.
            </li>
            <li>
                <strong>Identify Key Elements:</strong> Determine the elements directly related to the edge to be
                flipped: four vertices, six half-edges, two faces.
                <code>VertexIter v0, v1, v2, v3; HalfedgeIter h0, h1, h2, h3; FaceIter f0, f1;</code>
            </li>
            <img src="../hw2_IMGs/Task4 _IdentifyElements.png" alt="Identify Elements">
            <li>
                <strong>Update Pointers and Half-Edge Pointers of Vertices, Edges, and Faces:</strong> Reallocate
                the pointers of the half-edges to reflect the new connections.
                <code>h0-&gt;setNeighbors(...), h1-&gt;setNeighbors(...), ...</code> Ensure that each half-edge's
                next, twin, vertex, edge, and face pointers are correctly directed towards the appropriate elements.
                And in this step I encountered the following errors:
            </li>
            <img src="../hw2_IMGs/Task4 _reassign_pointer.png" alt="Update Pointers">
            <img src="../hw2_IMGs/Task4 _Failed.png" alt="Failed attempts">
            <li>
                My Fix: This is a correction made by ChatGPT. I attempted to comprehend it, but it didn't seem to
                make sense. Regardless, I also revised my own code. After attending the office hours on Tuesday, I
                realized the issue was that the faces of h0_next and h1_next were not set correctly, as evident from
                the <span style="color: red;">red circle</span> in the image above. As long as I switch the surface, it functions well.<span style="font-style: italic;">😁</span>
            </li>
            <img src="../hw2_IMGs/Task4 _success.png" alt="Fixed">

        </ol>

    </div>
</section>

<footer>
    <div class="container">
        <p>Computer Graphics Class, 2024</p>
    </div>
</footer>
</body>

</html>